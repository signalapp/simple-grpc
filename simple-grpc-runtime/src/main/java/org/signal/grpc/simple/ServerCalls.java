/*
 * Copyright 2025 Signal Messenger, LLC
 * SPDX-License-Identifier: AGPL-3.0-only
 */

package org.signal.grpc.simple;

import io.grpc.Status;
import io.grpc.StatusException;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.ServerCallStreamObserver;
import io.grpc.stub.StreamObserver;
import java.util.concurrent.Flow;
import java.util.function.Function;

/**
 * Bridges calls from the gRPC framework to application-space service implementations.
 */
public class ServerCalls {

  private ServerCalls() {}

  /**
   * Handles unary (single-request, single-response) calls from a service stub generated by {@code SimpleGrpcGenerator}.
   *
   * @param request the request object from the client
   * @param responseObserver the response observer used by the server to send signals to the client
   * @param delegate the service method that will handle the business logic of this request
   * @param exceptionMapper a function that maps exceptions thrown by the {@code delegate} function to an appropriate
   *                        gRPC {@link Status}
   *
   * @param <Req> the type of request object handled by the {@code delegate} function
   * @param <Resp> the type of response object returned by the {@code delegate} function
   */
  public static <Req, Resp> void unaryCall(
      final Req request,
      final ServerCallStreamObserver<Resp> responseObserver,
      final CheckedFunction<Req, Resp> delegate,
      final Function<Exception, Throwable> exceptionMapper) {

    try {
      final Resp response = delegate.apply(request);

      // Don't try to respond if the server has already canceled the request
      if (!responseObserver.isCancelled()) {
        responseObserver.onNext(response);
        responseObserver.onCompleted();
      }
    } catch (final Exception e) {
      final Throwable mappedException = exceptionMapper.apply(e);

      // Don't try to respond if the server has already canceled the request
      if (!responseObserver.isCancelled()) {
        responseObserver.onError(mappedException);
      }
    }
  }

  public static <Req, Resp> void serverStreamingCall(
      final Req request,
      final ServerCallStreamObserver<Resp> responseObserver,
      final Function<Req, Flow.Publisher<Resp>> delegate,
      final Function<Exception, Throwable> exceptionMapper) {

    throw new UnsupportedOperationException();
  }

  public static <Req, Resp> StreamObserver<Req> clientStreamingCall(
      final ServerCallStreamObserver<Resp> responseObserver,
      final CheckedFunction<Flow.Publisher<Req>, Resp> delegate,
      final Function<Exception, Throwable> exceptionMapper) {

    throw new UnsupportedOperationException();
  }

  public static <Req, Resp> StreamObserver<Req> bidirectionalStreamingCall(
      final ServerCallStreamObserver<Resp> responseObserver,
      final Function<Flow.Publisher<Req>, Flow.Publisher<Resp>> delegate,
      final Function<Exception, Throwable> exceptionMapper) {

    throw new UnsupportedOperationException();
  }

  /**
   * Performs a default mapping of exceptions to {@code StatusException}. Exceptions that are already instances of
   * {@link StatusException} or {@link StatusRuntimeException} are returned unchanged. If the given exception is not
   * a {@code StatusException} or {@code StatusRuntimeException} but is caused by one of those classes, then the
   * status-bearing cause is returned.
   *
   * @param e the exception to map to a gRPC {@code StatusException}
   *
   * @return a {@code StatusException} or {@code StatusRuntimeException} derived from the given exception
   */
  public static Throwable mapException(final Exception e) {
    if (e instanceof StatusException || e instanceof StatusRuntimeException) {
      return e;
    } else {
      return Status.fromThrowable(e).asException();
    }
  }
}
